{
  "question_text": "Note: This question is part of a series of questions that present the same scenario. Each question in the series contains a unique solution that might meet the stated goals. Some question sets might have more than one correct solution, while others might not have a correct solution.<br/>After you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.<br/>You have a KQL database that contains two tables named Stream and Reference. Stream contains streaming data in the following format.<br/><br/><img src=\"images/dp-700_topic-2_question-18_html_1.png\" title=\"image57\"/><br/>Reference contains reference data in the following format.<br/><br/><img src=\"images/dp-700_topic-2_question-18_html_2.png\" title=\"image58\"/><br/>Both tables contain millions of rows.<br/>You have the following KQL queryset.<br/><br/><img src=\"images/dp-700_topic-2_question-18_html_3.png\" title=\"image59\"/><br/>You need to reduce how long it takes to run the KQL queryset.<br/>Solution: You change the join type to kind=outer.<br/><br/>Does this meet the goal?",
  "question_images": [
    "images/dp-700_topic-2_question-18_question_1.png",
    "images/dp-700_topic-2_question-18_question_2.png",
    "images/dp-700_topic-2_question-18_question_3.png"
  ],
  "answers": {
    "A": "Yes",
    "B": "No"
  },
  "answer_images": {},
  "correct_answer": [
    "B"
  ],
  "correct_answer_images": [],
  "discussion": "No. An outer join can be more computationally intensive than an inner join because it needs to process all rows from both tables and include rows that don't have matching entries.\n\n1.tell the engine to broadcast the small reference avoids a costly distributed shuffle. In KQL:\n| join hint.strategy=broadcast kind=inner (\n    Reference | project DeviceId, DeviceName\n) on DeviceId\n\nEven if Reference is narrow, hint.strategy=broadcast gives you predictable performance.\n2.Materialize a frequently-used static table â€” if Reference is static but read many times in a larger query pipeline:\nlet Ref = materialize(Reference | project DeviceId, DeviceName);\n...\n| join kind=inner Ref on DeviceId\nmaterialize() caches the result for the query, which can help when the engine would otherwise recompute or re-read it.\n\nAn outer join returns all rows from both tables, with nulls where there's no match.\n\nThis results in more data to process, which increases execution time, especially when both Stream and Reference tables have millions of rows.\n\nincrease data",
  "question_type": "multiple_choice",
  "exam": "dp-700",
  "topic": 2,
  "question_number": 18,
  "url": "https://www.examtopics.com/discussions/microsoft/view/153740-exam-dp-700-topic-2-question-18-discussion/"
}